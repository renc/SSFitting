<html>
    <head>
      <title>OpenMesh: OpenMesh::Subdivider::Adaptive::CompositeT&lt; M &gt; Class Template Reference</title>
      <link href="acg_style.css" rel="stylesheet" text="text/css">
      <link href="acg_tabs.css" rel="stylesheet" type="text/css">
    </head>
    <body bgcolor="#003010">
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceOpenMesh.html">OpenMesh</a>::<b>Subdivider</b>::<a class="el" href="namespaceOpenMesh_1_1Subdivider_1_1Adaptive.html">Adaptive</a>::<a class="el" href="classOpenMesh_1_1Subdivider_1_1Adaptive_1_1CompositeT.html">CompositeT</a>
  </div>
</div>
<div class="contents">
<h1>OpenMesh::Subdivider::Adaptive::CompositeT&lt; M &gt; Class Template Reference</h1><!-- doxytag: class="OpenMesh::Subdivider::Adaptive::CompositeT" --><a class="el" href="namespaceOpenMesh_1_1Subdivider_1_1Adaptive.html" title="Software related to adaptive subdivision of meshes.">Adaptive</a> Composite Subdivision framework.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="Adaptive_2Composite_2CompositeT_8hh_source.html">CompositeT.hh</a>&gt;</code>
<p>
<div class="dynheader">
Collaboration diagram for OpenMesh::Subdivider::Adaptive::CompositeT&lt; M &gt;:</div>
<div class="dynsection">
<p><center><img src="classOpenMesh_1_1Subdivider_1_1Adaptive_1_1CompositeT__coll__graph.png" border="0" usemap="#OpenMesh_1_1Subdivider_1_1Adaptive_1_1CompositeT_3_01M_01_4__coll__map" alt="Collaboration graph"></center>
<map name="OpenMesh_1_1Subdivider_1_1Adaptive_1_1CompositeT_3_01M_01_4__coll__map">
<area shape="rect" href="classOpenMesh_1_1PolyMesh__ArrayKernelT.html" title="Polygonal mesh based on the ArrayKernel." alt="" coords="571,5,859,32"><area shape="rect" href="classOpenMesh_1_1PolyMeshT.html" title="PolyMesh_ArrayKernel_GeneratorT\&lt;Traits\&gt;::Mesh" alt="" coords="147,5,461,32"><area shape="rect" href="classOpenMesh_1_1Subdivider_1_1Adaptive_1_1RuleInterfaceT.html" title="OpenMesh::Subdivider::Adaptive::RuleInterfaceT\&lt; M \&gt;" alt="" coords="545,112,884,139"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classOpenMesh_1_1Subdivider_1_1Adaptive_1_1CompositeT-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>DeleteRule</b></td></tr>

<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6a7324f11505d0140f4ce947c3e7872a"></a><!-- doxytag: member="OpenMesh::Subdivider::Adaptive::CompositeT::Rule" ref="6a7324f11505d0140f4ce947c3e7872a" args="" -->
typedef <a class="el" href="classOpenMesh_1_1Subdivider_1_1Adaptive_1_1RuleInterfaceT.html">RuleInterfaceT</a>&lt; M &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>Rule</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a75c59efa30d205c67d551d1cc7e5339"></a><!-- doxytag: member="OpenMesh::Subdivider::Adaptive::CompositeT::Mesh" ref="a75c59efa30d205c67d551d1cc7e5339" args="" -->
typedef M&nbsp;</td><td class="memItemRight" valign="bottom"><b>Mesh</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="27da6988470ed03567f5d4f39f850c97"></a><!-- doxytag: member="OpenMesh::Subdivider::Adaptive::CompositeT::RuleSequence" ref="27da6988470ed03567f5d4f39f850c97" args="" -->
typedef std::vector&lt; <a class="el" href="classOpenMesh_1_1Subdivider_1_1Adaptive_1_1RuleInterfaceT.html">Rule</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>RuleSequence</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="94af1e7b58406bbd5cdd2df34389ac5e"></a><!-- doxytag: member="OpenMesh::Subdivider::Adaptive::CompositeT::VH" ref="94af1e7b58406bbd5cdd2df34389ac5e" args="" -->
typedef M::VertexHandle&nbsp;</td><td class="memItemRight" valign="bottom"><b>VH</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6706919876617cbceb3fe854a3fd2769"></a><!-- doxytag: member="OpenMesh::Subdivider::Adaptive::CompositeT::FH" ref="6706919876617cbceb3fe854a3fd2769" args="" -->
typedef M::FaceHandle&nbsp;</td><td class="memItemRight" valign="bottom"><b>FH</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="77f680a429898a23ad7874257ce816c0"></a><!-- doxytag: member="OpenMesh::Subdivider::Adaptive::CompositeT::EH" ref="77f680a429898a23ad7874257ce816c0" args="" -->
typedef M::EdgeHandle&nbsp;</td><td class="memItemRight" valign="bottom"><b>EH</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cd6d1e782257d9c352076571c6e8f493"></a><!-- doxytag: member="OpenMesh::Subdivider::Adaptive::CompositeT::HH" ref="cd6d1e782257d9c352076571c6e8f493" args="" -->
typedef M::HalfedgeHandle&nbsp;</td><td class="memItemRight" valign="bottom"><b>HH</b></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="14acda841f3f50918ce31e07b56ba507"></a><!-- doxytag: member="OpenMesh::Subdivider::Adaptive::CompositeT::CompositeT" ref="14acda841f3f50918ce31e07b56ba507" args="(Mesh &amp;_mesh)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenMesh_1_1Subdivider_1_1Adaptive_1_1CompositeT.html#14acda841f3f50918ce31e07b56ba507">CompositeT</a> (Mesh &amp;_mesh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenMesh_1_1Subdivider_1_1Adaptive_1_1CompositeT.html#d80960eb4a617e8bd46fdebdf842c4f1">cleanup</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset <code>self</code> to state after the default constructor except of the mesh.  <a href="#d80960eb4a617e8bd46fdebdf842c4f1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="18fd11270e399c7ede5f9a45373cf193"></a><!-- doxytag: member="OpenMesh::Subdivider::Adaptive::CompositeT::initialize" ref="18fd11270e399c7ede5f9a45373cf193" args="(void)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenMesh_1_1Subdivider_1_1Adaptive_1_1CompositeT.html#18fd11270e399c7ede5f9a45373cf193">initialize</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize faces, edges, vertices, and rules. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="605bb0924e9dcd347bdf9ec7eac4f0b4"></a><!-- doxytag: member="OpenMesh::Subdivider::Adaptive::CompositeT::refine" ref="605bb0924e9dcd347bdf9ec7eac4f0b4" args="(typename Mesh::FaceHandle &amp;_fh)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenMesh_1_1Subdivider_1_1Adaptive_1_1CompositeT.html#605bb0924e9dcd347bdf9ec7eac4f0b4">refine</a> (typename Mesh::FaceHandle &amp;_fh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Refine one face. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e59f65fcb47e21523f2bfe16a36872e3"></a><!-- doxytag: member="OpenMesh::Subdivider::Adaptive::CompositeT::refine" ref="e59f65fcb47e21523f2bfe16a36872e3" args="(typename Mesh::VertexHandle &amp;_vh)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenMesh_1_1Subdivider_1_1Adaptive_1_1CompositeT.html#e59f65fcb47e21523f2bfe16a36872e3">refine</a> (typename Mesh::VertexHandle &amp;_vh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Raise one vertex to next final level. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e33f9634758aeb49fa9dc0efc2adf6b9"></a><!-- doxytag: member="OpenMesh::Subdivider::Adaptive::CompositeT::subdiv_type" ref="e33f9634758aeb49fa9dc0efc2adf6b9" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenMesh_1_1Subdivider_1_1Adaptive_1_1CompositeT.html#e33f9634758aeb49fa9dc0efc2adf6b9">subdiv_type</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return subdivision split type (3 for 1-to-3 split, 4 for 1-to-4 split). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="af00f4079a52c5227768530d9355620f"></a><!-- doxytag: member="OpenMesh::Subdivider::Adaptive::CompositeT::subdiv_rule" ref="af00f4079a52c5227768530d9355620f" args="() const " -->
const <a class="el" href="classOpenMesh_1_1Subdivider_1_1Adaptive_1_1RuleInterfaceT.html">Rule</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>subdiv_rule</b> () const </td></tr>

<tr><td colspan="2"><div class="groupHeader">Managing composite rules</div></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename R &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structOpenMesh_1_1Subdivider_1_1Adaptive_1_1RuleHandleT.html">RuleHandleT</a>&lt; R &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenMesh_1_1Subdivider_1_1Adaptive_1_1CompositeT.html#97528a2cd2f689e58016c376bca1425d">add</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add new rule to rule sequence by passing the type of the wanted rule as template argument to the method.  <a href="#97528a2cd2f689e58016c376bca1425d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename R &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structOpenMesh_1_1Subdivider_1_1Adaptive_1_1RuleHandleT.html">RuleHandleT</a>&lt; R &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenMesh_1_1Subdivider_1_1Adaptive_1_1CompositeT.html#2c9d88ad718bc61c5dfa0986a4963f9b">add</a> (<a class="el" href="structOpenMesh_1_1Subdivider_1_1Adaptive_1_1RuleHandleT.html">RuleHandleT</a>&lt; R &gt; &amp;_rh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add new rule to rule sequence by passing an appropriate handle to the method.  <a href="#2c9d88ad718bc61c5dfa0986a4963f9b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename R &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structOpenMesh_1_1Subdivider_1_1Adaptive_1_1RuleHandleT.html">RuleHandleT</a>&lt; R &gt;::<a class="el" href="classOpenMesh_1_1Subdivider_1_1Adaptive_1_1RuleInterfaceT.html">Rule</a> &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenMesh_1_1Subdivider_1_1Adaptive_1_1CompositeT.html#004f0208d282727b71dae29b7afb2cf7">rule</a> (const <a class="el" href="structOpenMesh_1_1Subdivider_1_1Adaptive_1_1RuleHandleT.html">RuleHandleT</a>&lt; R &gt; &amp;_rh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get rule in the rule sequence by a handle.  <a href="#004f0208d282727b71dae29b7afb2cf7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classOpenMesh_1_1Subdivider_1_1Adaptive_1_1RuleInterfaceT.html">RuleInterfaceT</a>&lt; M &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenMesh_1_1Subdivider_1_1Adaptive_1_1CompositeT.html#8df1c3098721d47a64c64f9bbafe5639">rule</a> (size_t _idx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get rule (interface) by index.  <a href="#8df1c3098721d47a64c64f9bbafe5639"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="856933d180069ff4e125b9edd255a5e9"></a><!-- doxytag: member="OpenMesh::Subdivider::Adaptive::CompositeT::n_rules" ref="856933d180069ff4e125b9edd255a5e9" args="() const " -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenMesh_1_1Subdivider_1_1Adaptive_1_1CompositeT.html#856933d180069ff4e125b9edd255a5e9">n_rules</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of rules in the rule sequence. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a1df06a3b549bb28ba66246f9b70a0b0"></a><!-- doxytag: member="OpenMesh::Subdivider::Adaptive::CompositeT::rules_as_string" ref="a1df06a3b549bb28ba66246f9b70a0b0" args="(const std::string &amp;_sep=&quot; * &quot;) const " -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenMesh_1_1Subdivider_1_1Adaptive_1_1CompositeT.html#a1df06a3b549bb28ba66246f9b70a0b0">rules_as_string</a> (const std::string &amp;_sep=&quot; * &quot;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the sequence as string. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="67016440ffcea2d18c973e9b958b95f9"></a><!-- doxytag: member="OpenMesh::Subdivider::Adaptive::CompositeT::rules" ref="67016440ffcea2d18c973e9b958b95f9" args="() const " -->
const RuleSequence &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenMesh_1_1Subdivider_1_1Adaptive_1_1CompositeT.html#67016440ffcea2d18c973e9b958b95f9">rules</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The rule sequence. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="773a6e846c083d83325949d2795fd17c"></a><!-- doxytag: member="OpenMesh::Subdivider::Adaptive::CompositeT::generation" ref="773a6e846c083d83325949d2795fd17c" args="(state_t _s)" -->
<a class="el" href="namespaceOpenMesh_1_1Subdivider_1_1Adaptive.html#f706613543b0da1b097580a9dc30fc6e">state_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>generation</b> (<a class="el" href="namespaceOpenMesh_1_1Subdivider_1_1Adaptive.html#f706613543b0da1b097580a9dc30fc6e">state_t</a> _s)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="af7bfe6880bebd31900bba50b75a2ce6"></a><!-- doxytag: member="OpenMesh::Subdivider::Adaptive::CompositeT::generation" ref="af7bfe6880bebd31900bba50b75a2ce6" args="(VH _vh)" -->
<a class="el" href="namespaceOpenMesh_1_1Subdivider_1_1Adaptive.html#f706613543b0da1b097580a9dc30fc6e">state_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>generation</b> (VH _vh)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f3ccdb29c74567d610fd22dc81fca9a4"></a><!-- doxytag: member="OpenMesh::Subdivider::Adaptive::CompositeT::generation" ref="f3ccdb29c74567d610fd22dc81fca9a4" args="(EH _eh)" -->
<a class="el" href="namespaceOpenMesh_1_1Subdivider_1_1Adaptive.html#f706613543b0da1b097580a9dc30fc6e">state_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>generation</b> (EH _eh)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a41a3f023fd6c4296f9b570547fb6271"></a><!-- doxytag: member="OpenMesh::Subdivider::Adaptive::CompositeT::generation" ref="a41a3f023fd6c4296f9b570547fb6271" args="(FH _fh)" -->
<a class="el" href="namespaceOpenMesh_1_1Subdivider_1_1Adaptive.html#f706613543b0da1b097580a9dc30fc6e">state_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>generation</b> (FH _fh)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename M&gt;<br>
 class OpenMesh::Subdivider::Adaptive::CompositeT&lt; M &gt;</h3>

<a class="el" href="namespaceOpenMesh_1_1Subdivider_1_1Adaptive.html" title="Software related to adaptive subdivision of meshes.">Adaptive</a> Composite Subdivision framework. 
<p>
The adaptive composite subdivision framework is based on the work done by P. Oswald and P. Schroeder. This framework elevates the uniform case of the composite scheme to the adaptive setting.<p>
For details on the composite scheme refer to<ul>
<li><a href="http://cm.bell-labs.com/who/poswald/sqrt3.pdf">P. Oswald, P. Schroeder "Composite primal/dual sqrt(3)-subdivision schemes", CAGD 20, 3, 2003, 135--164</a></li></ul>
<p>
For details on the transition from uniform to adaptive composite subdivision please refer to<ul>
<li>&lt;a href="http://www.eg.org/EG/DL/PE/OPENSG03/04sovakar.pdf&gt;A. von Studnitz, A. Sovakar, L. Kobbelt "API Design for <a class="el" href="namespaceOpenMesh_1_1Subdivider_1_1Adaptive.html" title="Software related to adaptive subdivision of meshes.">Adaptive</a> Subdivision Schemes" OpenSG Symposium 2003</li></ul>
<p>
In the composite scheme a subdivision operator is created by combining smaller "atomic" rules. Depending on the selection and ordering of the operator many known subdivision schemes can be created.<p>
Every rule inherits from <a class="el" href="classOpenMesh_1_1Subdivider_1_1Adaptive_1_1RuleInterfaceT.html" title="Base class for adaptive composite subdivision rules.">RuleInterfaceT</a> and is represented out of the subdivider object by a <a class="el" href="structOpenMesh_1_1Subdivider_1_1Adaptive_1_1RuleHandleT.html" title="Handle template for adaptive composite subdividion rules.">RuleHandleT</a> (as usual within OpenMesh). You can add rules using the CompositeT::add() functions. The correct order of adding the rules is very important, and furthermore not all rules get along with each other very well. (Please read the given literature, especially the paper by Oswald and Schrï¿½der.)<p>
To use a composite subdivider first define a rule sequence describing the order of execution of the rules. In the order the rules habe been added they will be executed. E.g. the rules given in operator notation have to added from right to left.<p>
After the rule sequence has been defined the subdivider has to be intialized using CompositeT::initialize(). If everything went well, use CompositeT::refine() to subdivide locally a face or vertex.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Not all (topological) operators have been implemented! <p>
Only triangle meshes are supported. <p>
The rule sequence must begin with a topological operator.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classOpenMesh_1_1Subdivider_1_1Adaptive_1_1RuleInterfaceT.html" title="Base class for adaptive composite subdivision rules.">RuleInterfaceT</a>, <a class="el" href="structOpenMesh_1_1Subdivider_1_1Adaptive_1_1RuleHandleT.html" title="Handle template for adaptive composite subdividion rules.">RuleHandleT</a> </dd></dl>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="2c9d88ad718bc61c5dfa0986a4963f9b"></a><!-- doxytag: member="OpenMesh::Subdivider::Adaptive::CompositeT::add" ref="2c9d88ad718bc61c5dfa0986a4963f9b" args="(RuleHandleT&lt; R &gt; &amp;_rh)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOpenMesh_1_1Subdivider_1_1Adaptive_1_1RuleHandleT.html">RuleHandleT</a>&lt;R&gt;&amp; OpenMesh::Subdivider::Adaptive::CompositeT&lt; M &gt;::add           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structOpenMesh_1_1Subdivider_1_1Adaptive_1_1RuleHandleT.html">RuleHandleT</a>&lt; R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_rh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add new rule to rule sequence by passing an appropriate handle to the method. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Valid handle on success. Else it is invalid. </dd></dl>

</div>
</div><p>
<a class="anchor" name="97528a2cd2f689e58016c376bca1425d"></a><!-- doxytag: member="OpenMesh::Subdivider::Adaptive::CompositeT::add" ref="97528a2cd2f689e58016c376bca1425d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOpenMesh_1_1Subdivider_1_1Adaptive_1_1RuleHandleT.html">RuleHandleT</a>&lt;R&gt; OpenMesh::Subdivider::Adaptive::CompositeT&lt; M &gt;::add           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add new rule to rule sequence by passing the type of the wanted rule as template argument to the method. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Valid handle on success. Else it is invalid. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d80960eb4a617e8bd46fdebdf842c4f1"></a><!-- doxytag: member="OpenMesh::Subdivider::Adaptive::CompositeT::cleanup" ref="d80960eb4a617e8bd46fdebdf842c4f1" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void OpenMesh::Subdivider::Adaptive::CompositeT&lt; M &gt;::cleanup           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reset <code>self</code> to state after the default constructor except of the mesh. 
<p>

</div>
</div><p>
<a class="anchor" name="8df1c3098721d47a64c64f9bbafe5639"></a><!-- doxytag: member="OpenMesh::Subdivider::Adaptive::CompositeT::rule" ref="8df1c3098721d47a64c64f9bbafe5639" args="(size_t _idx)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenMesh_1_1Subdivider_1_1Adaptive_1_1RuleInterfaceT.html">RuleInterfaceT</a>&lt;M&gt;&amp; OpenMesh::Subdivider::Adaptive::CompositeT&lt; M &gt;::rule           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>_idx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get rule (interface) by index. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The wanted rule if the handle is valid. The return value is undefined if the handle is invalid! </dd></dl>

</div>
</div><p>
<a class="anchor" name="004f0208d282727b71dae29b7afb2cf7"></a><!-- doxytag: member="OpenMesh::Subdivider::Adaptive::CompositeT::rule" ref="004f0208d282727b71dae29b7afb2cf7" args="(const RuleHandleT&lt; R &gt; &amp;_rh)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOpenMesh_1_1Subdivider_1_1Adaptive_1_1RuleHandleT.html">RuleHandleT</a>&lt;R&gt;::<a class="el" href="classOpenMesh_1_1Subdivider_1_1Adaptive_1_1RuleInterfaceT.html">Rule</a>&amp; OpenMesh::Subdivider::Adaptive::CompositeT&lt; M &gt;::rule           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structOpenMesh_1_1Subdivider_1_1Adaptive_1_1RuleHandleT.html">RuleHandleT</a>&lt; R &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>_rh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get rule in the rule sequence by a handle. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The wanted rule if the handle is valid. The return value is undefined if the handle is invalid! </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>src/OpenMesh/Tools/Subdivider/Adaptive/Composite/<a class="el" href="Adaptive_2Composite_2CompositeT_8hh_source.html">CompositeT.hh</a><li>src/OpenMesh/Tools/Subdivider/Adaptive/Composite/<a class="el" href="Adaptive_2Composite_2CompositeT_8cc.html">CompositeT.cc</a></ul>
</div>
<hr>
<address>
<small>
<a href="http://www.rwth-graphics.de" style="text-decoration:none;">
<img src="acg_icon.gif" alt="acg pic" align="middle" border=0>
</a>
Project <b>OpenMesh</b>, 
&copy;&nbsp; Computer Graphics Group, RWTH Aachen.
Documentation generated using 
<a class="el" href="http://www.doxygen.org/index.html">
<b>doxygen</b>
</a>.
</small>
</address>
</body>
</html>
