<html>
    <head>
      <title>OpenMesh: Extending the mesh using traits</title>
      <link href="acg_style.css" rel="stylesheet" text="text/css">
      <link href="acg_tabs.css" rel="stylesheet" type="text/css">
    </head>
    <body bgcolor="#003010">
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="tutorial_07">Extending the mesh using traits </a></h1>This examples shows:<p>
<ul>
<li>How to extend the behaviour of entities using traits.</li></ul>
<p>
In the previous tutorial we used attributes and changed the type of the data types <code>Point</code>, <code>Normal</code>, <code>TexCoord</code>, and <code>Color</code>. But we can do even more with traits. We can change the behaviour of the mesh entities <code>Vertex</code>, <code>Face</code>, <code>Edge</code>, and <code>Halfedge</code>.<p>
One goal in the design was a highly customizable data structure. Using the traits technique makes it possible. We pick up the smoother again and show an alternative way to implement it. Now we place the necessary data and the functions in the vertex itself<p>
 <div class="fragment"><pre class="fragment"><span class="keyword">struct </span>MyTraits : <span class="keyword">public</span> OpenMesh::DefaultTraits
{
  <span class="comment">// store barycenter of neighbors in this member</span>
  <a class="code" href="Core_2Mesh_2Traits_8hh.html#a5146d858418fcb93715406a6ce8e30f" title="Macro for defining the vertex traits. See Specifying your MyMesh.">VertexTraits</a>
  {
  <span class="keyword">private</span>:
    Point  cog_;
  <span class="keyword">public</span>:

    VertexT() : cog_( Point(0.0f, 0.0f, 0.0f ) ) { }

    <span class="keyword">const</span> Point&amp; cog()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> cog_; }
    <span class="keywordtype">void</span> set_cog(<span class="keyword">const</span> Point&amp; _p) { cog_ = _p; }
  };
};
</pre></div><p>
Note the definition of the vertex entity. We use the supplied define <code>VertexTraits</code> (which resolves in a rather inconvenient template definition). Similary we can use the defines <code>FaceTraits</code>, <code>EdgeTraits</code>, and <code>HalfedgeTraits</code> to extend these entities. Now we enhanced the vertex, with the additional member variable <code>cog_</code>, and the get/set-method pair to access the new member.<p>
As before we compute in a first loop the barycenters for all vertices and store the information at the vertices<p>
<div class="fragment"><pre class="fragment">      v_it-&gt;set_cog(cog / valence);
</pre></div><p>
In the second pass we set the new position of each vertex<p>
<div class="fragment"><pre class="fragment">        mesh.set_point( v_it.handle(), v_it-&gt;cog());
</pre></div><p>
It looks neat, but on the other hand we can't remove the data anymore as we could do with properties! By using traits one creates a 'static' configuration, which can't be changed during runtime.<p>
The complete source looks like this:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;vector&gt;</span>
<span class="comment">// -------------------- OpenMesh</span>
<span class="preprocessor">#include &lt;OpenMesh/Core/IO/MeshIO.hh&gt;</span>
<span class="preprocessor">#include &lt;OpenMesh/Core/Mesh/TriMesh_ArrayKernelT.hh&gt;</span>


<span class="preprocessor">#ifndef DOXY_IGNORE_THIS</span>
<span class="preprocessor"></span>
<span class="keyword">struct </span>MyTraits : <span class="keyword">public</span> OpenMesh::DefaultTraits
{
  <span class="comment">// store barycenter of neighbors in this member</span>
  <a class="code" href="Core_2Mesh_2Traits_8hh.html#a5146d858418fcb93715406a6ce8e30f" title="Macro for defining the vertex traits. See Specifying your MyMesh.">VertexTraits</a>
  {
  <span class="keyword">private</span>:
    Point  cog_;
  <span class="keyword">public</span>:

    VertexT() : cog_( Point(0.0f, 0.0f, 0.0f ) ) { }

    <span class="keyword">const</span> Point&amp; cog()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> cog_; }
    <span class="keywordtype">void</span> set_cog(<span class="keyword">const</span> Point&amp; _p) { cog_ = _p; }
  };
};

<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="keyword">typedef</span> <a class="code" href="classOpenMesh_1_1TriMesh__ArrayKernelT.html" title="Triangle mesh based on the ArrayKernel.">OpenMesh::TriMesh_ArrayKernelT&lt;MyTraits&gt;</a>  MyMesh;
<span class="keyword">typedef</span> <a class="code" href="classOpenMesh_1_1TriMesh__ArrayKernelT.html" title="Triangle mesh based on the ArrayKernel.">OpenMesh::TriMesh_ArrayKernelT&lt;&gt;</a>          <a class="code" href="classOpenMesh_1_1TriMesh__ArrayKernelT.html" title="Triangle mesh based on the ArrayKernel.">MyMesh2</a>;

<span class="comment">// ---------------------------------------------------------------------------</span>
<span class="preprocessor">#define SIZEOF( entity,b ) \</span>
<span class="preprocessor">  std::cout &lt;&lt; _prefix &lt;&lt; "size of " &lt;&lt; #entity &lt;&lt; ": " \</span>
<span class="preprocessor">            &lt;&lt; sizeof( entity ) &lt;&lt; std::endl;          \</span>
<span class="preprocessor">  b += sizeof( entity )</span>
<span class="preprocessor"></span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Mesh&gt; 
<span class="keywordtype">void</span> print_size(<span class="keyword">const</span> std::string&amp; _prefix = <span class="stringliteral">""</span>)
{
  <span class="keywordtype">size_t</span> total=0;
  SIZEOF(Mesh::Vertex, total);
  SIZEOF(Mesh::Halfedge, total);
  SIZEOF(Mesh::Edge, total);
  SIZEOF(Mesh::Face, total);
  std::cout &lt;&lt; _prefix &lt;&lt; <span class="stringliteral">"total: "</span> &lt;&lt; total &lt;&lt; std::endl;
}

<span class="preprocessor">#undef SIZEOF</span>
<span class="preprocessor"></span><span class="comment">// ---------------------------------------------------------------------------</span>


<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
{
  MyMesh  mesh;

  <span class="comment">// check command line options</span>
  <span class="keywordflow">if</span> (argc &lt; 4 || argc &gt; 5) 
  {
    std::cerr &lt;&lt; <span class="stringliteral">"Usage:  "</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">" [-s] #iterations infile outfile\n"</span>;
    exit(1);
  }

  <span class="keywordtype">int</span> idx=2;

  <span class="comment">// display size of entities of the enhanced and the default mesh type</span>
  <span class="comment">// when commandline option '-s' has been used.</span>
  <span class="keywordflow">if</span> (argc == 5)
  {
    <span class="keywordflow">if</span> (std::string(<span class="stringliteral">"-s"</span>)==argv[idx-1])
    {
      std::cout &lt;&lt; <span class="stringliteral">"Enhanced mesh size statistics\n"</span>;
      print_size&lt;MyMesh&gt;(<span class="stringliteral">"  "</span>);
      
      std::cout &lt;&lt; <span class="stringliteral">"Default mesh size statistics\n"</span>;
      print_size&lt;MyMesh2&gt;(<span class="stringliteral">"  "</span>);
    }
    <span class="comment">// else ignore!</span>
    ++idx;
  }


  <span class="comment">// read mesh from stdin</span>
  std::cout&lt;&lt; <span class="stringliteral">" Input mesh: "</span> &lt;&lt; argv[idx] &lt;&lt; std::endl;
  <span class="keywordflow">if</span> ( ! <a class="code" href="namespaceOpenMesh_1_1IO.html#e4b7d0255a084aca13f5c7a553b86e72" title="Read a mesh from file _filename.">OpenMesh::IO::read_mesh</a>(mesh, argv[idx]) )
  {
    std::cerr &lt;&lt; <span class="stringliteral">"Error: Cannot read mesh from "</span> &lt;&lt; argv[idx] &lt;&lt; std::endl;
    <span class="keywordflow">return</span> 0;
  }



  <span class="comment">// smoothing mesh argv[1] times</span>
  MyMesh::VertexIter          v_it, v_end(mesh.vertices_end());
  <a class="code" href="classOpenMesh_1_1PolyMeshT.html#dc7d422e2ce13141e8291f7d29f7ecef" title="Circulator.">MyMesh::VertexVertexIter</a>    vv_it;
  <a class="code" href="classOpenMesh_1_1PolyMeshT.html#ed10fb4dfb536b53a5e20c8f2442eadf" title="Coordinate type.">MyMesh::Point</a>               cog;
  <a class="code" href="classOpenMesh_1_1PolyMeshT.html#15372f27edf521d8e9028e2abccae342" title="Scalar type.">MyMesh::Scalar</a>              valence;
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                i, N(atoi(argv[idx-1]));

  std::cout&lt;&lt; <span class="stringliteral">"Smooth mesh "</span> &lt;&lt; N &lt;&lt; <span class="stringliteral">" times\n"</span>;

  <span class="keywordflow">for</span> (i=0; i &lt; N; ++i)
  {
    <span class="keywordflow">for</span> (v_it=mesh.vertices_begin(); v_it!=v_end; ++v_it)
    {
      cog[0] = cog[1] = cog[2] = valence = 0.0;
      
      <span class="keywordflow">for</span> (vv_it=mesh.vv_iter(v_it.handle()); vv_it; ++vv_it)
      {
        cog += mesh.point( vv_it.handle() );
        ++valence;
      }

      v_it-&gt;set_cog(cog / valence);
    }
    
    <span class="keywordflow">for</span> (v_it=mesh.vertices_begin(); v_it!=v_end; ++v_it)
      <span class="keywordflow">if</span> (!mesh.is_boundary(v_it.handle()))
        mesh.set_point( v_it.handle(), v_it-&gt;cog());
  }


  <span class="comment">// write mesh to stdout</span>
  std::cout&lt;&lt; <span class="stringliteral">"Output mesh: "</span> &lt;&lt; argv[idx+1] &lt;&lt; std::endl;

  <span class="keywordflow">if</span> ( ! <a class="code" href="namespaceOpenMesh_1_1IO.html#b6b68cf71ede53756653b31bd0e292a5" title="Write a mesh to the file _filename.">OpenMesh::IO::write_mesh</a>(mesh, argv[idx+1]) )
  {
      std::cerr &lt;&lt; <span class="stringliteral">"Error: cannot write mesh to "</span> &lt;&lt; argv[idx+1] &lt;&lt; std::endl;
      <span class="keywordflow">return</span> 0;
  }
  <span class="keywordflow">return</span> 1;
}

</pre></div> </div>
<hr>
<address>
<small>
<a href="http://www.rwth-graphics.de" style="text-decoration:none;">
<img src="acg_icon.gif" alt="acg pic" align="middle" border=0>
</a>
Project <b>OpenMesh</b>, 
&copy;&nbsp; Computer Graphics Group, RWTH Aachen.
Documentation generated using 
<a class="el" href="http://www.doxygen.org/index.html">
<b>doxygen</b>
</a>.
</small>
</address>
</body>
</html>
